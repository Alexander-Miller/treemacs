# -*- fill-column: 120 -*-

* Content                                                                            :TOC:noexport:
- [[#treemacs-extension-tutorial][Treemacs Extension Tutorial]]
   - [[#intro][Intro]]
   - [[#setup-basics][Setup Basics]]
   - [[#defining-node-types][Defining Node Types]]
   - [[#enabling-the-extension][Enabling the extension]]
   - [[#asynchronous-nodes][Asynchronous Nodes]]
   - [[#variadic-nodes-and-non-treemacs-buffers][Variadic nodes and non-treemacs buffers]]
   - [[#monotyped-nodes][Monotyped nodes]]
- [[#old-version-treemacs-extension-tutorial][[OLD VERSION] Treemacs Extension Tutorial]]
   - [[#try-it][Try it]]
   - [[#extensions-for-projects][Extensions for Projects]]
   - [[#extension-for-directories][Extension for Directories]]
   - [[#extensions-at-the-top-level][Extensions at the Top level]]
   - [[#extensions-beyond-treemacs][Extensions beyond Treemacs]]
   - [[#node-navigation-and-updates][Node Navigation and Updates]]
   - [[#setting-the-working-directory][Setting the Working Directory]]
   - [[#about-properties][About Properties]]

* Treemacs Extension Tutorial
** Intro

The following is a step-by-step guide on how to create extensions for treemacs using its ~treelib~ api.  The example
used is a simple view of all existing buffers, except those that are hidden, grouped by their major-mode.

The code in this file is loadable with ~org-babel-load-file~, you can see tehe results by calling (TODO)
~showcase-display-buffer-list~.

** Setup Basics

First our basic dependencies:

#+BEGIN_SRC emacs-lisp
  ;; -*- lexical-binding: t -*-

  (require 'dash)
  (require 'treemacs)
  (require 'treemacs-treelib)
#+END_SRC

Since we are grouping buffers by their major-mode we will need two data sources:
- The list of the major-modes of all current buffers as our entry point
- The list of all buffers for a given major-mode

Both sources are filtered for hidden buffers whose names start with a space.

#+BEGIN_SRC emacs-lisp
  (defun treemacs-showcase--buffer-major-modes ()
    (->> (buffer-list)
         (--reject (string-prefix-p " " (buffer-name it)))
         (--map (buffer-local-value 'major-mode it))
         (-distinct)))

  (defun treemacs-showcase--buffers-by-mode (mode)
    (->> (buffer-list)
         (--filter (eq mode (buffer-local-value 'major-mode it)))
         (--reject (string-prefix-p " " (buffer-name it)))))
#+END_SRC

We will also define a command to open a buffer using RET:
(The ignored argument is the prefix arg; the ~:button~ text property will be stored by ourselves)

#+BEGIN_SRC emacs-lisp
  (defun treemacs-showcase-RET-buffer-action (&optional _)
    (-> (treemacs-current-button)
        (treemacs-button-get :buffer)
        (pop-to-buffer)))
#+END_SRC

** Defining Node Types

Now comes the interesting part, we will use treemacs' api to tell it how we want our new trees to look, how they should
fetch the information they display, and where to put them.

The entry point for an extension is created with ~treemacs-define-entry-node-type~. A detailed explanation and
documentation for every single argument can be found in the eldoc of ~treemacs-do-define-extension-type~, so here we'll
only summarise the most important points:

- ~:label~ is the text next to the icon.
- The ~:key~ of every extension should be semi-unique - it does not need to be unique all on its own, but the "path" of
  all the keys leading to a node must serve as a unique identifier for it, otherwise treemacs will not be able to find
  the node and operations like updating it will not work.
- The ~:children~ are what gets displayed when you expand a node of this type. Other than being a list there are no
  rules for the structure or content of the items returned here. The nodes we define just need to be able to extract the
  information they need from this list (as we'll see in a bit).
- The argument values or not just static. They can contain arbitrary code that will be executed on every access (though
  of course it should be kept lean for performance reasons). When applicable they will also have implicit access to the
  individual ~:children~ being rendered as we'll see in the next example.

#+BEGIN_SRC emacs-lisp
  (treemacs-define-entry-node-type showcase-buffers
    :key 'showcase-buffers
    :label "Buffers"
    :open-icon (treemacs-get-icon-value 'list)
    :closed-icon (treemacs-get-icon-value 'list)
    :children (treemacs-showcase--buffer-major-modes)
    :face 'font-lock-keyword-face
    :child-type 'showcase-buffer-group)
#+END_SRC

We have created our entry point whose ~:children~ will be our buffers' major-modes. We set its ~:child-type~ to be
~showcase-buffer-group~, and that means that we now must create a node type with just that name.

Simple expandable nodes that are neither entry points nor leaves in our tree can be defined with
~treemacs-define-expandable-node-type~.

Here we can see that the individual item, as returned by the previous nodes definition's ~:children~ (in this case the
major mode symbol), is bound as ~item~, so we can use it to extract the information we need. We can save additional
information as text properties in our node with ~:more-properties~ (a plist). We use that to save the exact major-mode
so we can later use it query a buffer-group node's children.

Finally ~:children~ is special in that it has access to 2 parameters:
- The ~item~ being rendered, as returned by its parent's ~:children~ data source
- The ~btn~ for the node at point, as returned by ~treemacs-current-button~
  (the value is a text-properties button as it would be created by the builtin button.el library, hence the name)

#+BEGIN_SRC emacs-lisp
  (treemacs-define-expandable-node-type showcase-buffer-group
    :closed-icon "+ "
    :open-icon "- "
    :label (symbol-name item)
    :face 'font-lock-variable-name-face
    :key item
    :children (treemacs-showcase--buffers-by-mode (treemacs-button-get btn :major-mode))
    :child-type 'showcase-buffer-leaf
    :more-properties `(:major-mode ,item))
#+END_SRC

Finally all that's left is to define the leaves of our tree - the nodes for the individual buffers.

Nothing of further interest is happening here, we merely save the buffers in a text property so the command to open them
that we have defined above can use that information.

#+BEGIN_SRC emacs-lisp
  (treemacs-define-leaf-node-type showcase-buffer-leaf
    :icon "â€¢ "
    :label (buffer-name item)
    :key (buffer-name item)
    :face 'font-lock-string-face
    :more-properties `(:buffer ,item)
    :ret-action #'treemacs-showcase-RET-buffer-action)
#+END_SRC

** Enabling the extension

All that's left now it to tell treemacs to actually use the extension we have created. There are 3 options for where the
it should be placed:

- at the top-level, the same level as your projects
- under a project
- under a directory

We can also decide whether our extension goes at the top or the bottom of its location.

The latter two options may also accept a ~:predicate~ argument, so it is possible to determine exactly which projects
and directories an extension will be used for.

For our example we will place the extension at the top of the first project in the workspace:

#+BEGIN_SRC emacs-lisp
  (treemacs-enable-project-extension
   :extension 'showcase-buffers
   :position 'top
   :predicate (lambda (project) (eq project (car (treemacs-workspace->projects (treemacs-current-workspace))))))
#+END_SRC

The argument passed to ~:extension~ must be the same symbol that was used for ~treemacs-define-entry-node-type~.

** Asynchronous Nodes

Treemacs also supports nodes that fetch their content from an asynchronous source like a language server.
For our simple example we will re-use the buffer code from above and use timers to fake asynchronicity.

Most of the code is the same, there are only 2 differences:
- async nodes must set the ~:async~ flag to a non-nil value
- ~:children~ is different in that it receives a third argument: a ~callback~ function that must be called with the
  produced items once they are available

#+BEGIN_SRC emacs-lisp
  (treemacs-define-entry-node-type showcase-async-buffers
    :key 'showcase-buffers-async
    :label "Async Buffers"
    :open-icon (treemacs-get-icon-value 'list)
    :closed-icon (treemacs-get-icon-value 'list)
    :children
    (let ((items (treemacs-showcase--buffer-major-modes)))
      (run-with-timer
       (1+ (random 3)) nil
       (lambda () (funcall callback items))))
    :face 'font-lock-keyword-face
    :child-type 'showcase-async-buffer-group
    :async? t)
#+END_SRC

Leaves have no asynchronous parts, so the previous definition can be re-used directly.

#+BEGIN_SRC emacs-lisp
  (treemacs-define-expandable-node-type showcase-async-buffer-group
    :closed-icon "+ "
    :open-icon "- "
    :label (symbol-name item)
    :face 'font-lock-variable-name-face
    :key item
    :children
    (let ((items (treemacs-showcase--buffers-by-mode (treemacs-button-get btn :major-mode))))
      (run-with-timer
       (1+ (random 3)) nil
       (lambda () (funcall callback items))))
    :child-type 'showcase-buffer-leaf
    :more-properties `(:major-mode ,item)
    :async? t)
#+END_SRC

We'll enable the asynchronous extension at the bottom of /first/ project in treemacs:

#+BEGIN_SRC emacs-lisp
  (treemacs-enable-project-extension
   :extension 'showcase-async-buffers
   :predicate (lambda (project) (eq project (car (treemacs-workspace->projects (treemacs-current-workspace)))))
   :position 'bottom)
#+END_SRC

** Variadic nodes and non-treemacs buffers

Treemacs' extensions do not have to be used excessively within treemacs itself, they may also be put into their own
buffers. When doing so it might be useful for an extension to produce multiple top-level nodes from the start, instead
of having one single entry point, like the ~Buffers~ node from the first example.

Treemacs calls this concept ~variadic~ nodes. The following example will demonsrate how to set up such a variadic
extension that will produce major-mode buffer group nodes at the top level, and how display this extension in its own
side window.

Most of the code from above can be re-used, we just need a new entry point, which we create with
~treemacs-define-variadic-entry-node-type~. The setup is the same as for ~treemacs-define-entry-node-type~, except
this time we need to define a ~:children~ parameter (and being an entry point all parameters that would normally be
available when querying the ~:children~ are of course nil). Since we are creating major-mode groups the children will
simply be a list of the current buffers' major modes:

#+BEGIN_SRC emacs-lisp
  (treemacs-define-variadic-entry-node-type showcase-buffers-variadic
    :key 'showcase-buffers-variadic
    :label (symbol-name item)
    :open-icon (treemacs-get-icon-value 'list)
    :closed-icon (treemacs-get-icon-value 'list)
    :children (->> (buffer-list)
                   (--reject (string-prefix-p " " (buffer-name it)))
                   (--map (buffer-local-value 'major-mode it))
                   (-distinct))
    :face 'font-lock-variable-name-face
    :child-type 'showcase-buffer-group)
#+END_SRC


That's it. Now we just need to define an interactive command that will display our buffers for us:

#+BEGIN_SRC emacs-lisp
  (defun showcase-buffer-groups ()
    (interactive)
    (let ((bufname "*Showcase Buffers*"))
      (--when-let (get-buffer bufname) (kill-buffer it))
      (let ((buf (get-buffer-create bufname)))
        (pop-to-buffer buf)
        (treemacs-initialize 'showcase-buffers-variadic))))
        #+END_SRC

~treemacs-initialize~ must be called for the buffer to be used by treemacs. It must be used *before* any buffer-local
values are set because the initialization will switch the major-mode to ~treemacs-mode~, which erases buffer-local
values.

Note that a variadic extension call be updated as if it was a single node. To refresh /all/ the buffer groups we have
produced we just need to call ~(treemacs-update-node 'showcase-buffers-variadic)~.

** Monotyped nodes

Defining every node type individually is not necessary, it is possible to make do with a single definition. Some
verbosity will remain because now it is necessary to dispatch (at a high enough scale, probably thousands of items, it
might even impact performance), but it can still be worth it if the number of node types is exceptionally high.

Treemacs calls this the ~monotyped~ approach to defining extensions.

Here we combine both the buffer groups and individual buffer leaves into a single definition:
(Note how the name of the extension and the ~:child-type~ are one and the same)

#+BEGIN_SRC emacs-lisp
  (treemacs-define-expandable-node-type showcase-monotype-buffers
    :closed-icon
    (if (bufferp item)
        "â€¢ "
      "+ ")
    :open-icon
    (if (bufferp item)
        "â€¢"
      "- ")
    :label
    (if (bufferp item)
        (buffer-name item)
      (symbol-name item))
    :face
    (if (bufferp item)
        'font-lock-string-face
      'font-lock-variable-name-face)
    :key
    (if (bufferp item)
        (buffer-name item)
      item)
    :children
    (when (symbolp item)
      (treemacs-showcase--buffers-by-mode item))
    :child-type
    'showcase-monotype-buffers
    :more-properties
    (if (bufferp item)
        `(:buffer ,item :leaf t)
      `(:major-mode ,item)))
#+END_SRC

Note that a non-nil ~:leaf~ property must be placed manually, since without a distinct node state this is the only way
for treemacs to know that the node is a leaf and cannot be expanded.

Entry points cannot be combined, they still need to be set up individually:

#+BEGIN_SRC emacs-lisp
  (treemacs-define-entry-node-type showcase-buffers-monotype-entry
    :key 'showcase-buffers-monotype-entry
    :label "Monotype Buffers"
    :open-icon (treemacs-get-icon-value 'list)
    :closed-icon (treemacs-get-icon-value 'list)
    :children (treemacs-showcase--buffer-major-modes)
    :more-properties nil
    :face 'font-lock-keyword-face
    :child-type 'showcase-monotype-buffers)
#+END_SRC

Finally we'll enable the new extension to appear in our first project:

#+BEGIN_SRC emacs-lisp
  (treemacs-enable-project-extension
   :extension 'showcase-buffers-monotype-entry
   :predicate (lambda (project) (eq project (car (treemacs-workspace->projects (treemacs-current-workspace)))))
   :position 'top)
#+END_SRC

* [OLD VERSION] Treemacs Extension Tutorial                                          :ARCHIVE:
** Try it
The code in this file is loadable with ~org-babel-load-file~, you can see tehe results by calling
~showcase-display-buffer-list~.
** Extensions for Projects

First our dependencies:

#+BEGIN_SRC emacs-lisp :tangle no
  (require 'treemacs)
  (require 'dash)
#+END_SRC

Now let's define a source for the data we'll be displaying: a list of buffers, grouped by their major modes, with
transient buffers (whose names start with a space) removed. It doesn't really make much sense to add a buffer list like
that under some project, but this example is 1) reasonably practical, and 2) very simple, allowing us to concentrate on
integrating it with treemacs.

#+BEGIN_SRC emacs-lisp :tangle no
  (defun showcase--get-buffer-groups ()
    "Get the list of buffers, grouped by their major mode."
    (->> (buffer-list)
         (--reject (eq ?\ (aref (buffer-name it) 0)))
         (--group-by (buffer-local-value 'major-mode it))))
#+END_SRC

The output of this function would look roughly like this. This is the structure our extension will have when we're done.

#+BEGIN_SRC emacs-lisp :tangle no
  ; ((org-mode
  ;   #<buffer Extensions.org>)
  ;  (emacs-lisp-mode
  ;   #<buffer init.el>
  ;   #<buffer treemacs-customization.el>
  ;   #<buffer *scratch*>
  ;   #<buffer treemacs-extensions.el>)
  ;  (spacemacs-buffer-mode
  ;   #<buffer *spacemacs*>)
  ;  (messages-buffer-mode
  ;   #<buffer *Messages*>)
  ;  (compilation-mode
  ;   #<buffer *Compile-Log*>)
  ;  (magit-status-mode
  ;   #<buffer magit: treemacs>))
#+END_SRC

Before we begin defining what our nodes look like we will slightly get ahead of ourselves and define the function that
allows us to visit the buffer node at point. The buffer that is represented by the node will be stored in its ~:buffer~
property, so all we need to do is extract it, make sure it's alive, and show it in ~next-window~. The function could
make use of the prefix argument, but we won't us it here. This function can now be used to give our leaf nodes a TAB,
RET, or double-mouse1 action (the latter is a work in progress).

#+BEGIN_SRC emacs-lisp :tangle no
  (defun showcase-visit-buffer (&rest _)
    "Switch to the buffer saved in node at point."
    (let* ((node (treemacs-current-button))
           (buffer (treemacs-button-get node :buffer)))
      (when (buffer-live-p buffer)
        (select-window (next-window))
        (switch-to-buffer buffer))))
#+END_SRC

Now we'll get to building our custom treemacs tree. Node types are defined from the bottom up, so we start with the
leaves of our tree, nodes that represent some specific buffer. ~treemacs-define-leaf-node~ needs 3 things: a name, an
icon, and optional keyword arguments for TAB, RET, and doubleclick actions. This is why we defined our visit-buffer
command in advance. Instead of using ~treemacs-as-icon~ to iconize a string you can also use ~treemacs-icon-for-file~ or
directly use one of treemacs' own icons (like ~treemacs-icon-css~).

#+BEGIN_SRC emacs-lisp :tangle no
  (treemacs-define-leaf-node buffer-leaf
    (treemacs-as-icon "â€¢ " 'face 'font-lock-builtin-face)
    :ret-action #'showcase-visit-buffer
    :tab-action #'showcase-visit-buffer
    :mouse1-action (lambda (&rest args) (interactive) (showcase-visit-buffer args)))
#+END_SRC

Now we move further up and define our first expandable node type that represents a group of buffers with a specific
major mode. This is where it gets interesting. Aside from the two icons for the node being either open or closed we need
a query function and a render action. The former will be called by treemacs to this node is expanded and must provide
a list of child nodes to display.

In the context of the invocation of the query function the node being expanded is bound under the name ~node~. Under all
its layers of abstraction treemacs' nodes (specifically the text and not the icons) are buttons as per
the builtin ~button.el~ library. Its functions (or rather their faster treemacs variants) can all be invoked on treemacs
nodes, including ~treemacs-button-get~, which we use here to retrieve the list of buffers that we will have stored in
the node's ~:buffers~ property.

In the next step treemacs will loop over the list returned by the query function, invoking the render action form for
each. Every element in the iteration will be bound as ~item~. Whatever code is used in the render action, it must end in
a call to ~treemacs-render-node~, which creates the strings treemacs will be inserting. It requires an icon, a display
name, an initial state, a face, a (reasonably) unique key, and an optional list of arbitrary additional properties to
store.

Here we can see why node definition must go bottom to top. The leaf node definition from above has given us the
variables for both the icon and the initial state. Since we are iterating over a list of buffers we can use the buffer
name for the display label. Buffers are also unique, so we can use them as the node's unique key as well. There are
requirements for the choice of the face. Finally we also store the buffer in every node's ~:buffer~ property so we can
later use it in ~showcase-visit-buffer~.

#+BEGIN_SRC emacs-lisp :tangle no
  (treemacs-define-expandable-node buffer-group
    :icon-open (treemacs-as-icon "- " 'face 'font-lock-string-face)
    :icon-closed (treemacs-as-icon "+ " 'face 'font-lock-string-face)
    :query-function (treemacs-button-get node :buffers)
    :render-action
    (treemacs-render-node
     :icon treemacs-buffer-leaf-icon
     :label-form (buffer-name item)
     :state treemacs-buffer-leaf-state
     :face 'font-lock-string-face
     :key-form item
     :more-properties (:buffer item)))
#+END_SRC

Third things third we define a root node to hold the list of buffers together. It works much the same way as just
defining an expandable node, but requires additional information. So far we've created a small render chain. Buffers are
rendered by buffers groups, buffer groups are rendered by the buffer root, but the buffer root is not rendered by the
next highest node, but by treemacs itself. So we set ~:root-marker~ to t and provide a ~:root-label~, ~:root-face~ and a
~:root-key-form~, same as when calling into ~treemacs-render-node~.

#+BEGIN_SRC emacs-lisp :tangle no
  (treemacs-define-expandable-node buffers-root
    :icon-open (treemacs-as-icon "- " 'face 'font-lock-string-face)
    :icon-closed (treemacs-as-icon "+ " 'face 'font-lock-string-face)
    :query-function (showcase--get-buffer-groups)
    :render-action
    (treemacs-render-node
     :icon treemacs-icon-buffer-group-closed
     :label-form (symbol-name (car item))
     :state treemacs-buffer-group-closed-state
     :face 'font-lock-keyword-face
     :key-form (car item)
     :more-properties (:buffers (cdr item)))
    :root-marker t
    :root-label "Buffers"
    :root-face 'font-lock-type-face
    :root-key-form 'Buffers)
#+END_SRC

This code will have defined a function called ~treemacs-BUFFERS-ROOT-extension~ which we can use as our extension, but
first we need another, final building block. We are building an extension for projects, but we have yet to decide
/which/ projects it is for. In other words we need a predicate. So let's assume we want our extension to show up only
for the first project in the workspace.

#+BEGIN_SRC emacs-lisp :tangle no
  (defun showcase-extension-predicate (project)
    (eq project
        (-> (treemacs-current-workspace)
            (treemacs-workspace->projects)
            (car))))
#+END_SRC

With everything in place we can now tell treemacs about our extension. The final argument ~:position~ decides whether
the extension will be rendered at the very start or the very end of the project's immediate children.

#+BEGIN_SRC emacs-lisp :tangle no
  (treemacs-define-project-extension
   :extension #'treemacs-BUFFERS-ROOT-extension
   :predicate #'showcase-extension-predicate
   :position 'top)
#+END_SRC

** Extension for Directories

Extension for arbitraray directories work much the same way as extensions for projects. The only differences are that a
directory predicate takes a file path argument of type string and that the final call is made to
~treemacs-define-directory-extension~.

** Extensions at the Top level
It is also possible to place extensions at the very top of the display tree, on the same level as projects. To make this
work ~treemacs-define-expandable-node~ must receive not a ~:root-marker~, but a ~:top-level-marker~. Other than that
nothing changes and the same restrictions apply, but the ~treemacs-BUFFERS-ROOT-extension~ that we've created in our
example will be able to be passed to ~treemacs-define-top-level-extension~.

#+BEGIN_SRC emacs-lisp :tangle no
  (treemacs-define-top-level-extension
   :extension #'treemacs-BUFFERS-ROOT-extension
   :position 'top)
#+END_SRC

Every top-level element in treemacs has its own project struct and extensions are no different. It's even more important
in top-level extensions since the project object is required not just for internal house-keeping, but is needed to
address nodes in the given tree. To that end an extensions project is always found in a buffer local variable named
~treemacs-${name}-extension-project~, where ~${name}~ is the name passed to ~treemacs-define-expandable-node~.

Note that neither predicates, nor the use of a ~'bottom~ position have yet been implemented.

** Extensions beyond Treemacs

Finally you can also use the extensions api as a generalized set of building block for tree structures, to be used in
any other buffer. First let's define an appropriate extension. We will re-use the ~buffer-root~ code from above, except
this time we'll mark it as a ~:project~ and call it ~buffer-root-top~.

#+BEGIN_SRC emacs-lisp :tangle no
  (treemacs-define-expandable-node buffers-root-top
    :icon-open (treemacs-as-icon "- " 'face 'font-lock-string-face)
    :icon-closed (treemacs-as-icon "+ " 'face 'font-lock-string-face)
    :query-function (showcase--get-buffer-groups)
    :render-action
    (treemacs-render-node
     :icon treemacs-icon-buffer-group-closed
     :label-form (symbol-name (car item))
     :state treemacs-buffer-group-closed-state
     :face 'font-lock-keyword-face
     :key-form (car item)
     :more-properties (:buffers (cdr item)))
    :top-level-marker t
    :root-label "Buffers"
    :root-face 'font-lock-type-face
    :root-key-form 'Buffers)
#+END_SRC

With this we have all we need to display the buffer overview in any buffer of our choice. The required setup is minimal,
we just need to display such a buffer and call ~treemacs-initialize~ inside it, and the extension can be used:

#+BEGIN_SRC emacs-lisp :tangle no
  (defun showcase-display-buffer-list ()
    (interactive)
    (let* ((buffer (get-buffer-create "*Showcase Buffer List*"))
           (window (display-buffer-in-side-window buffer '((side . right)))))
      (select-window window)
      (treemacs-initialize)
      (treemacs-BUFFERS-ROOT-TOP-extension)))
#+END_SRC

** Node Navigation and Updates
~TODO~
** Setting the Working Directory
Treemacs sets the value of ~default-directory~ based on the nearest path at point. This allows commands like ~find-file~
and ~magit-status~ to do what you mean based on the current context. This option is also available for custom nodes:
just set the property ~:default-directory~ and treemacs will make use of its value when the node is in focus.
** About Properties
~treemacs-render-node~ allows to add arbitrary propertis to a node, which can quickly lead to subtle, difficult-to-trace
conflicts since treemacs itself makes extensive use of that option. To avoid such issues the following keywords and
symbols must not be used as properties:

 - ~:project~
 - ~:state~
 - ~:depth~
 - ~:path~
 - ~:key~
 - ~:parent~
 - ~:default-face~
 - ~:symlink~
 - ~:marker~
 - ~:index~
 - ~:custom~
 - ~'button~
 - ~'category~
 - ~'face~
 - ~'keymap~
